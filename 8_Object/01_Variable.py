# 변수는 상자가 아니다
# - 파이썬 변수는 자바에서의 참조 변수와 같으므로 변수는 객체에 붙은 레이블이라고 생각하는 것이 좋다
# - 변수는 상자라도 이해 할수 없는 예제
a = [1, 2, 3]
b = a
a.append(4)
b  # [1,2,3,4


# - 객체는 변수가 할당되기 전에 생성된다
class Gizmo:
    def __init__(self):
        print('Gizmo id: %d' % id(self))


x = Gizmo()
# y = Gizmo() * 100 # 에러가 발생하지만 곱셈을 시도하기 전에 두번째 기지모 객체가 실제로 생성되었음을 알 수 있따
print(dir())  # 하지만 윗줄에서 에러가 발생하였기 때문에 변수 y는 생성되지 않는

# - 변수는 단지 레이블일 뿐이므로 객체에 여러 레이블을 붙이지 못할 이유가 없다.
#   여러 레이블을 붙이는 것을 'alias(별명)'이라고 한다

# 정체성, 동질성, 별명

charls = {'name': 'Charles L. Dodgson', 'born': 1832}
lewis = charls
print(lewis is charls)  # True
print(
    id(charls), id(lewis)
)
lewis['balance'] = 950
print(charls)

alex = {'name': 'Charles L. Dodgon', 'born': 1832, 'balance': 950}
print(alex == charls)  # True
print(alex is not charls)  # True
# - 첫줄print -> dict 클래스에서 __eq__구현하는 방식 때문에 두 객체를 비교해서 같다고 판단한다
# - 두번째 줄 -> 이 두 객체는 거로 별개의 객체다. a is not 로 기술하는것은 두 객체의 정체성이 다르다고 표현하는 파이썬 방식이다

# - 여기에서 알 수 있는 것
#   - lewis 와 charles 는 별명이다. 두 변수가 동일 객체에 바인딩 되어 있따
#   - 반면 ales는 charles에 대한 별명이 아니다.
#   - 두 변수는 서로 다른 객체에 바인딩 되어있다 -> 바인딩된 객체가 동일한 '값'을 갖고 있으므로 == 연산자 결과는 True이다
#   - 하지만 정체성은 다르기 때문에 is로 물어보면 False 이다

# == 연산자와 is 연산자 간의 선택
# - is 는 정체성을 물어 보는 함수이고 == 는 값을 비교하는 함수 이다
# - is 연산자는 오버로딩할 수 없으므로 파이썬이 이 값을 평가하기 위해 특별 메서드를 호출할 필요가 없으므로 == 보다 빠르다
# - == 는 __eq__ 연산자와 통일한 결과를 산출한다. 따라서 오버라이드가 가능하다


# 튜플의 상대적 불변성
# - 리스트, 딕셔너리, 집합 등 대부분의 파이썬 컬렉션과 마찬가지로 튜플도 객체에 대한 참조를 담는다
# - 참조된 항목이 강변형이면 튜플 자체는 불변형이지만 참조된 항목은 변할 수 있다
# - 즉, 튜플의 불변성은 tuple 데이터 구체적의 물리적인 내용(참조 자체)만을 말하는 것이며, 참조된 객체까지 불변성을 가지는 것은 아니다
t1 = (1, 2, [30, 40])
t2 = (1, 2, [30, 40])
print(t1 == t2)  # True
print(t1[-1].append(99))
print(t1 == t2) # False
