# del과 가비지 컬렉션
# - del 명령은 이름을 제거하는 것이지, 객체를 제거하는 것이 아니다
# - del 명령의 결과로 객체가 가비지 컬렉트될수 있지만,
#   제거된 변수가 객체를 참조하는 최후의 변수거나 객체에 도달할 수 없을 때만 수거 된다
# - __del__ 이라는 특별 메서드가 있지만, 객체가 제거되도록 만들지 않으며, 사용자가 코드에서 직접 호출하면 안된다
#   이건 객체가 제거되기 직전에 외부 리소스를 해제할 기회를 주기 위해 파이썬 인터프리터가 호출한다
#   즉, 이건 건들지 마라


import weakref

s1 = {1, 2, 3}
s2 = s1


def bye():
    print('Gone with the wind...')


ender = weakref.finalize(s1, bye)  # finalize 함수는 객체를 감시하고 콜백을 호출하기 위해 준비한다, 콜백 함수로 bye 등록
print(ender.alive)

del s1
print(ender.alive)

s2 = 'spam'  # s1 에 도달할수 있는 마지막 참조객체가 사라진다 -> {1,2,3} 튜플 객체가 사라진다
print(ender.alive)

# s3 = s1 # 불가능 하다 -> 이미 s1이 사라졌기 때문
# print(ender.alive)

# - 튜플 객체가 사라진 이유
#   - s1 참조가 finalize 함수에 전달 되었고, 감시하고 있다면 s1에 대한 참조가 있는 것인데 왜 사라 졌을까
#   - 그 이유는 fianlize가 s1에 대한 '약한 참조'를 가지고 있기 때문이다


# 약한 참조
# - 객체가 메모리에 유지되거나 유지되지 않도록 만드는 것은 참조의 존재 여부다
# - 객채 참조 카운트가 0이 되면 가비지 컬렉터는 해당 객체를 제거한다
# - 그러나 불필요하게 객체를 유지시키지 않으면서 객체를 참조할 수 있으면 도움이 되는 경우가 종종있다 (대표적으로 캐시)

# - 약한 참조는 참조 카운트를 증가시키지 않고 객체를 참조한다
# - 참조의 대상인 객체를 '참조 대상' 이라고 한다
# - 따라서 약한 참조는 참조 대상이 가비지 컬렉트되는 것을 방지하지 않는다고 말할 수 있다
# - 약한 참조는 캐시 어플리케이션에서 유용하게 사용된다. 캐시가 참조하고 있다고 해서 캐시된 객체게 계속 남아 있기 원치 않기 때문

# - 약한 참조는 콜러블이다. 객체가 살아 있으면 참조된 객체를 반환하고, 그렇지 않으면 None을 반환한다
print()
a_set = {0, 1}
wref = weakref.ref(a_set)

print(wref())

a_set = {2, 3, 4}
print(wref())
